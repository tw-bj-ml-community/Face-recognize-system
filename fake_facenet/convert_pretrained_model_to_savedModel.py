'''
This file is used for convert the pretrained inception-resnet-v1 model to a SavedModel(Which is used by tensorflow serving)
'''
import os

from fake_facenet.inception_resnet_v1 import *

EXPORT_PATH = './tf_serving_model/'
MODEL_VERSION = 1

INPUT_SIZE = 160  # the shape of input of inception-resnet-v1 is batch_size,160,160,3
PB_PATH = './pretrained_model/20170512-110547.pb'
GRAPH_META_PATH = './pretrained_model/model-20170512-110547.meta'
CHECKPOINT_FILE = './pretrained_model/model-20170512-110547.ckpt-250000'


def load_graph_from_ckpt():
    saver = tf.train.import_meta_graph(GRAPH_META_PATH)
    # saver = tf.train.Saver()
    saver.restore(tf.get_default_session(), CHECKPOINT_FILE)


def load_graph_from_pb():
    with tf.gfile.GFile(PB_PATH, "rb") as f:
        graph_def = tf.GraphDef()
        graph_def.ParseFromString(f.read())
    tf.import_graph_def(graph_def)


def main():
    with tf.Graph().as_default():
        with tf.Session() as sess:
            load_graph_from_pb()

            # Get placeholders from the graph
            images_placeholder = tf.get_default_graph().get_tensor_by_name("import/input:0")
            embeddings = tf.get_default_graph().get_tensor_by_name("import/embeddings:0")
            phase_train_placeholder = tf.get_default_graph().get_tensor_by_name("import/phase_train:0")

            # export model to savedmodel

            # This is an path string like './model/1'
            export_model_path = os.path.join(EXPORT_PATH, str(MODEL_VERSION))
            print('Model saved to:', export_model_path)
            builder = tf.saved_model.builder.SavedModelBuilder(export_model_path)

            # SavedModel need tensor info like dtype and shape, this method build tensor_info protobuf for us.
            # For we need build tensor_info protobuf for all the input and output tensor.
            tensor_info_x = tf.saved_model.utils.build_tensor_info(images_placeholder)
            tensor_info_train = tf.saved_model.utils.build_tensor_info(phase_train_placeholder)
            tensor_info_y = tf.saved_model.utils.build_tensor_info(embeddings)

            # a signature here is like a method signature used for gRPC call.
            # we need specify the input, out, put and method name.
            prediction_signature = (
                tf.saved_model.signature_def_utils.build_signature_def(
                    inputs={'images': tensor_info_x, 'is_training': tensor_info_train},
                    outputs={'scores': tensor_info_y},
                    method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME))

            # build the model with previous signatrue, I only have one signature, so I make it the default one.
            # the legacy_init_op is used for compatibility with model generated by tf<1.2
            legacy_init_op = tf.group(tf.tables_initializer(), name='legacy_init_op')
            builder.add_meta_graph_and_variables(
                sess, [tf.saved_model.tag_constants.SERVING],
                signature_def_map={
                    tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY:
                        prediction_signature,
                },
                legacy_init_op=legacy_init_op)

            builder.save()


if __name__ == '__main__':
    main()
